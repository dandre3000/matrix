"use strict";const matrixSymbol=Symbol("Matrix");export const newMatrix=(r,e,t,o=new ArrayBuffer(r*e*8),n=0)=>{if(void 0===r)throw new TypeError("rows is not defined");if("number"!=typeof r)throw new TypeError("rows must be a number");if(r%1!=0)throw new RangeError("rows must be an integer");if(r<1)throw new RangeError("rows must be greater than or equal to 1");if(void 0===e)throw new TypeError("columns is not defined");if("number"!=typeof e)throw new TypeError("columns must be a number");if(e%1!=0)throw new RangeError("columns must be an integer");if(e<1)throw new RangeError("columns must be greater than or equal to 1");if(r*e>134217728)throw new RangeError("rows * columns must not be greater than 134217728");if(void 0!==t){if("object"!=typeof t)throw new TypeError("data must be an array of only numbers");if("number"!=typeof t.length)throw new TypeError("data.length must be an integer");if(t.length%1!=0)throw new RangeError("data.length must be an integer");if(t.length<0)throw new RangeError("data.length must be greater than or equal to 0");for(let r=0;r<t.length;r++)if("number"!=typeof t[r])throw new TypeError("data must be an array of only numbers")}if(o instanceof ArrayBuffer!=!0)throw new TypeError("buffer must be an ArrayBuffer");if(o.byteLength<r*e*8)throw new RangeError("buffer.byteLength must be greater than or equal to the minimum byteLength of the matrix (rows * columns * 8)");if("number"!=typeof n)throw new TypeError("byteOffset must be a number");if(n%1!=0)throw new RangeError("byteOffset must be an integer");if(n<0)throw new RangeError("byteOffset must be greater than or equal to 0");if(n>o.byteLength-r*e*8)throw new RangeError("byteOffset must be less than or equal to buffer.byteLength minus the byteLength of the matrix (rows * columns * 8)");const s=new Float64Array(o,n,r*e);if(void 0!==t){const r=Math.min(t.length,s.length);for(let e=0;e<r;e++)s[e]=t[e]}return Object.defineProperty(s,"rows",{value:r,configurable:!1,enumerable:!1,writable:!1}),Object.defineProperty(s,"columns",{value:e,configurable:!1,enumerable:!1,writable:!1}),Object.defineProperty(s,matrixSymbol,{value:!0,configurable:!1,enumerable:!1,writable:!1}),s};export const checkMatrix=r=>{if("object"!=typeof r||null===r)throw new TypeError("matrix must be an array of only numbers");if(1==r[matrixSymbol])return r;{const{columns:e,length:t,rows:o}=r;if(void 0===o)throw new TypeError("matrix.rows is not defined");if("number"!=typeof o)throw new TypeError("matrix.rows must be a number");if(o%1!=0)throw new RangeError("matrix.rows must be an integer");if(o<1)throw new RangeError("matrix.rows must be greater than or equal to 1");if(void 0===e)throw new TypeError("matrix.columns is not defined");if("number"!=typeof e)throw new TypeError("matrix.columns must be a number");if(e%1!=0)throw new RangeError("matrix.columns must be an integer");if(e<1)throw new RangeError("matrix.columns must be greater than or equal to 1");if("number"!=typeof r.length)throw new TypeError("matrix.length must be an integer");if(t%1!=0)throw new RangeError("matrix.length must be an integer");if(t<0)throw new RangeError("matrix.length must be greater than or equal to 0");if(t!==o*e)throw new TypeError("matrix.length must equal rows * columns");if(!1==(!0===ArrayBuffer.isView(r)&&r instanceof DataView==!1))for(let e=0;e<t;e++)if("number"!=typeof r[e])throw new TypeError("matrix must be an array of only numbers");return r}};export const isMatrix=r=>{if("object"!=typeof r||null===r)return!1;if(!0===r[matrixSymbol])return!0;{const{columns:e,length:t,rows:o}=r;if(void 0===o||"number"!=typeof o||o%1!=0||o<1||void 0===e||"number"!=typeof e||e%1!=0||e<1||"number"!=typeof r.length||t%1!=0||t<0||t!==o*e)return!1;if(!1==(!0===ArrayBuffer.isView(r)&&r instanceof DataView==!1))for(let e=0;e<t;e++)if("number"!=typeof r[e])return!1;return!0}};export const add=(r,e,t=newMatrix(r.rows,r.columns))=>{if(checkMatrix(r),checkMatrix(e),r.columns!==e.columns||r.rows!==e.rows)throw new RangeError("The dimensions of a must equal the dimensions of b");if(checkMatrix(t),t.columns!==r.columns||t.rows!==r.rows)throw new RangeError("The dimensions of the sum must equal the dimensions of a and b");for(let o=0;o<r.length;o++)t[o]=r[o]+e[o];return t};export const subtract=(r,e,t=newMatrix(r.rows,r.columns))=>{if(checkMatrix(r),checkMatrix(e),r.columns!==e.columns||r.rows!==e.rows)throw new RangeError("The dimensions of a must equal the dimensions of b");if(checkMatrix(t),t.columns!==r.columns||t.rows!==r.rows)throw new RangeError("The dimensions of the difference must equal the dimensions of a and b");for(let o=0;o<r.length;o++)t[o]=r[o]-e[o];return t};export const multiplyScalar=(r,e,t=newMatrix(r.rows,r.columns,r))=>{if(checkMatrix(r),"number"!=typeof e)throw new TypeError("b must be a number");if(checkMatrix(t),t.rows!==r.rows||t.columns!==r.columns)throw new Error("The dimensions of product must equal the dimensions of a");for(let r=0;r<t.length;r++)t[r]*=e;return t};export const divideScalar=(r,e,t=newMatrix(r.rows,r.columns,r))=>{if(checkMatrix(r),"number"!=typeof e)throw new TypeError("b must be a number");if(checkMatrix(t),t.rows!==r.rows||t.columns!==r.columns)throw new Error("The dimensions of quotient must equal the dimensions of a");for(let r=0;r<t.length;r++)t[r]/=e;return t};export const multiplyMatrix=(r,e,t=newMatrix(r.rows,e.columns))=>{if(checkMatrix(r),checkMatrix(e),r.columns!==e.rows)throw new RangeError("Number of columns in a must be equal to the number of rows in b");if(checkMatrix(t),t.rows!==r.rows||t.columns!==e.columns)throw new Error("The dimensions of the product must equal (a rows) * (b columns)");for(let o=0;o<r.rows;o++)for(let n=0;n<e.columns;n++){let s=0;for(let t=0;t<r.columns;t++)s+=r[o*r.columns+t]*e[t*e.columns+n];t[o*e.columns+n]=s}return t};export const rowSwitch=(r,e,t,o=newMatrix(r.rows,r.columns,r))=>{if(e===t)return r;if(checkMatrix(r),"number"!=typeof e)throw new TypeError("a must be an integer");if(e%1>0)throw new RangeError("a must be an integer");if(e<0||e>r.rows-1)throw new RangeError("a must be greater than or equal to 0 and less than matrix.rows");if("number"!=typeof t)throw new TypeError("b must be an integer");if(t%1>0)throw new RangeError("b must be an integer");if(t<0||t>r.rows-1)throw new RangeError("b must be greater than or equal to 0 and less than matrix.rows");if(checkMatrix(o),o.columns!==r.columns||o.rows!==r.rows)throw new RangeError("The dimensions of result must equal the dimensions of matrix");const n=r.columns;for(let s=0;s<n;s++){const a=r[e*n+s];o[e*n+s]=r[t*n+s],o[t*n+s]=a}return o};export const rowAdd=(r,e,t,o,n=newMatrix(r.rows,r.columns,r))=>{if(e===t)return r;if(checkMatrix(r),"number"!=typeof e)throw new TypeError("a must be an integer");if(e%1>0)throw new RangeError("a must be an integer");if(e<0||e>r.rows-1)throw new RangeError("a must be greater than or equal to 0 and less than matrix.rows");if("number"!=typeof t)throw new TypeError("b must be an integer");if(t%1>0)throw new RangeError("b must be an integer");if(t<0||t>r.rows-1)throw new RangeError("b must be greater than or equal to 0 and less than matrix.rows");if("number"!=typeof o)throw new TypeError("n must be a number");if(checkMatrix(n),n.columns!==r.columns||n.rows!==r.rows)throw new RangeError("The dimensions of result must equal the dimensions of matrix");const s=r.columns;for(let a=0;a<s;a++)n[t*s+a]+=r[e*s+a]*o;return n};export const rowMultiply=(r,e,t,o=newMatrix(r.rows,r.columns,r))=>{if(checkMatrix(r),"number"!=typeof e)throw new TypeError("a must be an integer");if(e%1>0)throw new RangeError("a must be an integer");if(e<0||e>r.rows-1)throw new RangeError("a must be greater than or equal to 0 and less than matrix.rows");if("number"!=typeof t)throw new TypeError("n must be a number");if(checkMatrix(o),o.columns!==r.columns||o.rows!==r.rows)throw new RangeError("The dimensions of result must equal the dimensions of matrix");if(1===t)return r;const n=r.columns;for(let r=0;r<n;r++)o[e*n+r]*=t;return o};export const transpose=(r,e)=>{checkMatrix(r);const{rows:t,columns:o}=r;if(void 0===e)e=newMatrix(o,t);else if(checkMatrix(e),e.rows!==o||e.columns!==t)throw new Error("The dimensions of the transpose must equal (matrix.columns) * (matrix.rows)");for(let n=0;n<t;n++)for(let s=0;s<o;s++)e[s*t+n]=r[n*o+s];return e};export const convertDOMMatrixToMatrix=r=>{if(r instanceof DOMMatrix==!1)throw new TypeError("domMatrix must be an instance of DOMMatrix");const e=newMatrix(4,4);for(let t=0;t<e.rows;t++)for(let o=0;o<e.columns;o++)e[t*e.columns+o]=r[`m${t+1}${o+1}`];return e};export const convertMatrixToDOMMatrix=r=>{checkMatrix(r);return new DOMMatrix(r)};export const formatDataRowMajor=r=>{checkMatrix(r);const e=new Array(r.rows);for(let r=0;r<e.length;r++)e[r]=[];for(let t=0;t<r.rows;t++)for(let o=0;o<r.columns;o++)e[t][o]=r[t*r.columns+o];return e};export const formatDataColumnMajor=r=>{checkMatrix(r);const e=new Array(r.columns);for(let r=0;r<e.length;r++)e[r]=[];for(let t=0;t<r.rows;t++)for(let o=0;o<r.columns;o++)e[o][t]=r[t*r.columns+o];return e};